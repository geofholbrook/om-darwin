; OM File Header - Saved 2015/06/20 18:50:05
; (6.1 :patc (om-make-point 10 10) (om-make-point 293 136) (om-make-point 1348 1187) "" 183 0 "2015/06/20 17:16:09" "2015/06/20 18:50:05")
; End File Header
; External resources 
; (list (list (quote :sound) "#P\"../../out-files/easy-out-8.aiff\"") (list (quote :abstraction) "#P\"../contours and pitch mapping/ratio2timesig.oml\""))
(in-package :om)(load-lib-for (quote ("om-geof" "om-darwin")))(setf *om-current-persistent* (om-load-patch1 "cb harm plus rhythm" (quote ((let ((box (om-load-boxcall (quote lispfun) "IDENTITY" (quote identity) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 378 97) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 250 18) (om-make-point 27 30) 5 "5" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DEFINE-SPECIES" (quote define-species) (quote ((om-load-inputfun (quote input-funbox) "" "FUN" nil))) (om-make-point 266 217) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxcall (quote patch-box) "ratio2timesig" (quote ("elements" "contours and pitch mapping" "ratio2timesig")) (quote ((om-load-inputfun (quote input-funbox) "" "R" nil))) (om-make-point 686 583) nil (list nil) "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR 2" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 577 729) (om-make-point 121 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "BUTLAST" (quote butlast) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 486 642) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 462 702) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAKE-ARR" (quote om-darwin::make-arr) (quote ((om-load-inputfun (quote input-funbox) "STARTS" "STARTS" nil) (om-load-inputfun (quote input-funbox) "PITCHES" "PITCHES" nil) (om-load-inputkeyword (quote input-keyword) "" "time-sig" (quote :time-sig) nil nil))) (om-make-point 436 844) (om-make-point 194 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ARR-REGIONS" (quote om-darwin::arr-regions) (quote ((om-load-inputfun (quote input-funbox) "ARR" "ARR" nil))) (om-make-point 302 580) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REGION-PITCH" (quote om-darwin::region-pitch) (quote ((om-load-inputfun (quote input-funbox) "REGION" "REGION" nil))) (om-make-point 126 540) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 315 673) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 516 548) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "PHENOTYPE" (quote om-darwin::phenotype) (quote ((om-load-inputfun (quote input-funbox) "SELF" "SELF" nil))) (om-make-point 271 527) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "EMBED-SPECIES" (quote embed-species) (quote ((om-load-inputfun (quote input-funbox) "" "SPEC" nil))) (om-make-point 160 358) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "apply-pauses" (om-load-lisp-abspatch "apply-pauses" 6.1 ";;; Edit a valid LAMBDA EXPRESSION for \"apply-pauses\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (pause-positions len)$  (loop for k from 0 to (1- len)$        with count = 0$        with ratios$        with time-sigs$        do$        (if (and (not (= count 0))$                 (member k pause-positions))$            (progn$              (push (/ count 8) ratios)$              (push (/ count 8) time-sigs)$              (push (/ count 8) time-sigs)$              (setf count 0))$          (progn$            (push 1/8 ratios)$            (incf count)))$$        finally return (list ratios time-sigs)))$        ") (quote ((om-load-inputfun (quote input-funbox) "" "PAUSE-POSITIONS" nil) (om-load-inputfun (quote input-funbox) "" "LEN" nil))) (om-make-point 512 447) nil (list (list (list 1/8 1/8 1/8 1/8 1/8 1/8 1/8 1/8 1/8 1/8 3/8 1/8 1/8 1/8 3/8 1/8 1/8 1/8 3/8 1/8 1/8 1/8 1/8 1/8) (list 3/8 3/8 3/8 3/8 3/8 3/8 1/8 1/8))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "1-" (quote 1-) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 502 97) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 445 132) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "num-pauses" 1 (om-make-point 684 58) "" "num-pauses" 5 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-GENE" (quote om-gene) (quote ((om-load-inputfun (quote input-funbox) "minimum value" "MIN" (quote 0-)) (om-load-inputfun (quote input-funbox) "maximum value" "MAX" 9))) (om-make-point 489 218) (om-make-point 137 67) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "N" 0))) (om-make-point 583 340) (om-make-point 210 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 129 827) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "num-notes" 0 (om-make-point 305 12) "" "num-notes" 24 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAKE-CB-HARMONICS" (quote make-cb-harmonics) (quote ((om-load-inputfun (quote input-funbox) "" "NUM-NOTES" 16))) (om-make-point 128 258) (om-make-point 167 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (8 1 1 1 nil 0) (8 0 2 0 nil 0) (2 0 3 1 nil 0) (3 0 4 0 nil 0) (7 0 4 1 nil 0) (1 0 4 2 nil 0) (9 0 5 0 nil 0) (6 0 7 0 nil 0) (5 0 7 1 nil 0) (11 0 8 0 nil 0) (10 0 9 0 nil 0) (19 0 10 0 nil 0) (16 0 11 0 nil 0) (18 0 11 1 nil 0) (18 0 12 0 nil 0) (13 0 15 0 nil 0) (12 0 15 1 nil 0) (15 0 16 0 nil 0) (14 0 16 1 nil 0) (4 0 17 0 nil 0) (18 0 19 0 nil 0))) 6.1 nil "" (om-make-point 258 195) (om-make-point 1274 951)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 214 112) nil (list nil) "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "CRITERIA" (om-load-patch-abs1 "CRITERIA" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 86 522) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "C-ONOPERONS" (quote c-onoperons) (quote ((om-load-inputfun (quote input-funbox) "" "EVAL" nil) (om-load-inputfun (quote input-funbox) "" "TEST" nil) (om-load-inputfun (quote input-funbox) "" "RATE" nil))) (om-make-point 145 217) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "pos-distance" (om-load-patch-abs1 "pos-distance" (quote ((let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 319 354) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 189 528) (om-make-point 96 57) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 360 657) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 129 20) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ABS" (quote abs) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil))) (om-make-point 352 454) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "-" (quote -) (quote ((om-load-inputfun (quote input-funbox) "NUM" "NUM" 0) (om-load-inputfun (quote input-funbox) "add-input" "add-input" 0))) (om-make-point 229 360) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "POS" (quote om-darwin::pos) (quote ((om-load-inputfun (quote input-funbox) "CB-HARMONICS-NOTE" "CB-HARMONICS-NOTE" nil))) (om-make-point 270 261) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "POS" (quote om-darwin::pos) (quote ((om-load-inputfun (quote input-funbox) "CB-HARMONICS-NOTE" "CB-HARMONICS-NOTE" nil))) (om-make-point 200 264) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 118 107) (om-make-point 189 59) nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((8 1 1 0 nil 0) (4 0 1 1 nil 0) (0 0 1 2 nil 0) (1 0 2 0 nil 0) (5 0 4 0 nil 0) (6 0 5 0 nil 0) (7 0 5 1 nil 0) (8 1 6 0 nil 0) (8 0 7 0 nil 0) (3 0 8 0 nil 0))) 6.1 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 50 75) nil (list nil) "l" "pos-distance"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 179 88) (om-make-point 48 30) (list 1 3) "(1 3)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "C-LIST" (quote c-list) (quote ((om-load-inputfun (quote input-funbox) "" "CS" nil) (om-load-inputfun (quote input-funbox) "" "CS" nil) (om-load-inputfun (quote input-funbox) "" "CS" nil) (om-load-inputfun (quote input-funbox) "" "CS" nil) (om-load-inputfun (quote input-funbox) "" "CS" nil))) (om-make-point 395 419) (om-make-point 465 67) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "string-replay" (om-load-lisp-abspatch "string-replay" 6.1 ";;; Edit a valid LAMBDA EXPRESSION for \"string-replay\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (spec)$  (loop for sub on (mapcar 'd::corde (d::operons spec))$        while (>= (length sub) 3)$        sum$        (if (or (= (first sub) (second sub))$                (= (first sub) (third sub))$                (= (second sub) (third sub)))$            1$          0)))$                       ") (quote ((om-load-inputfun (quote input-funbox) "" "SPEC" nil))) (om-make-point 518 58) nil (list nil) "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "CRITERION" (quote criterion) (quote ((om-load-inputfun (quote input-funbox) "" "EVALUATOR" nil) (om-load-inputfunmenu1 (quote input-funmenu) "" "SUBJECT" nil (list (list "operons" (quote :operons)) (list "onoperons" (quote :onoperons)) (list "regions" (quote :regions)) (list "adjacent" (quote :adjacent)) (list "adjacent-regions" (quote :adjacent-regions)) (list "adjacent-pitches" (quote :adjacent-pitches)) (list "elements" (quote :elements)) (list "adjacent-elements" (quote :adjacent-elements)) (list "dx" (quote :dx)) (list "signed-dx" (quote :signed-dx)) (list "attacks" (quote :attacks)) (list "nthcdr" (quote :nthcdr)) (list "pitch" (quote :pitch)) (list "pitch-class" (quote :pitch-class)) (list "melodic" (quote :melodic)) (list "signed-melodic" (quote :signed-melodic)) (list "chord" (quote :chord)))) (om-load-inputfun (quote input-funbox) "" "TEST-VALUE" nil) (om-load-inputfun (quote input-funbox) "" "RATE" nil))) (om-make-point 582 198) (om-make-point 111 67) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "CRITERION 2" (quote criterion) (quote ((om-load-inputfun (quote input-funbox) "" "EVALUATOR" nil) (om-load-inputfunmenu1 (quote input-funmenu) "" "SUBJECT" (quote :melodic) (list (list "operons" (quote :operons)) (list "onoperons" (quote :onoperons)) (list "regions" (quote :regions)) (list "adjacent" (quote :adjacent)) (list "adjacent-regions" (quote :adjacent-regions)) (list "adjacent-pitches" (quote :adjacent-pitches)) (list "elements" (quote :elements)) (list "adjacent-elements" (quote :adjacent-elements)) (list "dx" (quote :dx)) (list "signed-dx" (quote :signed-dx)) (list "attacks" (quote :attacks)) (list "nthcdr" (quote :nthcdr)) (list "pitch" (quote :pitch)) (list "pitch-class" (quote :pitch-class)) (list "melodic" (quote :melodic)) (list "signed-melodic" (quote :signed-melodic)) (list "chord" (quote :chord)))) (om-load-inputfun (quote input-funbox) "" "TEST-VALUE" nil) (om-load-inputfun (quote input-funbox) "" "RATE" nil))) (om-make-point 926 234) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 892 110) (om-make-point 69 30) (quote :melodic) ":melodic" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 945 50) (om-make-point 220 30) (list (quote :set) 0 50 100 500 700 1200 2400) "(:set 0 50 100 500 700 1200 2400)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 5" (quote t) (quote nil) (om-make-point 1013 161) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "note-replay" (om-load-lisp-abspatch "note-replay" 6.1 ";;; Edit a valid LAMBDA EXPRESSION for \"string-replay\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (pheno)$  (loop for sub on (mapcar 'd::region-pitch pheno)$        while (>= (length sub) 5)$        sum$        (let ((block (first-n sub 5)))$          (if (< (length (remove-duplicates block))$                 (length block))$              1$            0))))") (quote ((om-load-inputfun (quote input-funbox) "" "PHENO" nil))) (om-make-point 820 204) nil (list nil) "l" "note-replay"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "C-ONOPERONS" (quote c-onoperons) (quote ((om-load-inputfun (quote input-funbox) "" "EVAL" nil) (om-load-inputfun (quote input-funbox) "" "TEST" nil) (om-load-inputfun (quote input-funbox) "" "RATE" nil))) (om-make-point 401 233) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "str-distance" (om-load-patch-abs1 "str-distance" (quote ((let ((box (om-load-boxcall (quote lispfun) "CORDE" (quote om-darwin::corde) (quote ((om-load-inputfun (quote input-funbox) "CB-HARMONICS-NOTE" "CB-HARMONICS-NOTE" nil))) (om-make-point 161 244) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CORDE" (quote om-darwin::corde) (quote ((om-load-inputfun (quote input-funbox) "CB-HARMONICS-NOTE" "CB-HARMONICS-NOTE" nil))) (om-make-point 361 253) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 319 354) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 189 528) (om-make-point 96 57) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 360 657) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 129 20) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ABS" (quote abs) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil))) (om-make-point 352 454) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "-" (quote -) (quote ((om-load-inputfun (quote input-funbox) "NUM" "NUM" 0) (om-load-inputfun (quote input-funbox) "add-input" "add-input" 0))) (om-make-point 102 337) (om-make-point 110 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 120 108) (om-make-point 189 59) nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((8 0 0 0 nil 0) (8 1 1 0 nil 0) (8 1 3 0 nil 0) (6 0 3 1 nil 0) (2 0 3 2 nil 0) (3 0 4 0 nil 0) (7 0 6 0 nil 0) (1 0 7 0 nil 0) (0 0 7 1 nil 0) (5 0 8 0 nil 0))) 6.1 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 306 91) nil (list nil) "l" "str-distance"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 435 104) (om-make-point 48 30) (list 1 2) "(1 2)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((4 0 0 0 nil 0) (2 0 1 0 nil 0) (3 0 1 1 nil 0) (1 0 4 0 nil 0) (12 0 4 1 nil 0) (6 0 4 2 nil 0) (11 0 4 3 nil 0) (7 0 4 4 nil 0) (5 0 6 0 nil 0) (8 0 7 1 nil 0) (9 0 7 2 nil 0) (10 0 7 3 nil 0) (13 0 12 0 nil 0) (14 0 12 1 nil 0))) 6.1 nil "" (om-make-point 200 200) (om-make-point 1138 647)) (quote nil) (om-make-point 601 165) nil (list nil) nil "CRITERIA"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "VOICE" (quote voice) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "a list representing a rhythm tree" "tree" (list (quote ?) (list (list (list 4 4) (list 1 1 1 1))))) (om-load-inputfun (quote input-funbox) "a chord object, a list of chords, a list of midics, a list of lists of midics..." "chords" (list (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord))) (om-load-inputfun (quote input-funbox) "frequency of the quarter-note (default 60/mn)" "tempo" 60) (om-load-inputfun (quote input-funbox) "overlapping percentage between every successive chords, calculated from the second chord's duration" "legato" 100) (om-load-inputfun (quote input-funbox) "sub lists (one sub list per chord) indicating notes to be tied to notes of the same value, in a next chord" "ties" nil))) (om-make-point 106 759) (om-make-point 707 164) (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (3 (((4 4) ((1 (1 1)) (1 (1 1)) (1 (1 1)) (1 (1 1)))) ((4 4) ((1 (1 1)) (1 (1 1)) (1 (1 1)) (1 (1 1)))) ((4 4) ((1 (1 1)) (1 (1 1)) (1 (1 1)) (1 (1 1))))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (3600 3300)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (4300 3800)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (3100 2800)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (3800 3300)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (4200 3800)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (3500 2800)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (4200 3300)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5000 3800)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (4400 2800)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6200 4300)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5700 3800)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5450 3300)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5200 2800)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6600 3800)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6400 3300)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5600 2800)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6100 3300)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7400 4300)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6600 3800)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5700 3300)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6450 4300)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6200 3800)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5450 3300)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (4700 2800)) :ldur (quote (500 500)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord)))) :tempo (quote ((1/4 60) nil)) :legato 100 :ties (quote (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote nil)) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote (((0 0 0 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((0 0 1 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((0 1 0 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((0 1 1 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((0 2 0 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((0 2 1 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((0 3 0 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((0 3 1 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((1 0 0 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((1 0 1 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((1 1 0 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((1 1 1 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((1 2 0 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((1 2 1 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((1 3 0 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((1 3 1 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((2 0 0 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((2 0 1 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((2 1 0 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((2 1 1 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((2 2 0 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((2 2 1 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((2 3 0 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t))) ((2 3 1 0) (if (find-class (quote head-extra) nil) (make-instance (quote head-extra) :thehead "a" :from-file t)))))) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (quote gff) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :midi-player) 1 nil 1000 0 (om-make-point 1150 480) (om-make-point 180 426) 0 1 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "PREP-FOR-OUTPUT" (quote om-darwin::prep-for-output) (quote ((om-load-inputfun (quote input-funbox) "SPEC" "SPEC" nil))) (om-make-point 244 671) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "easy-out-8.aiff" (quote sound) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "a track index for multichannel mixing (0 = no specific track)" "tracknum" 0) (om-load-inputfun (quote input-funbox) "a list of markers (s)" "markers" nil))) (om-make-point 855 770) (om-make-point 457 79) (let ((newobj (let ((thesound (load-sound (om-make-pathname :directory (quote (:relative "out-files")) :device :unspecific :host :unspecific :name "easy-out-8" :type "aiff") 0 100 0))) (when thesound (setf (markers thesound) (quote nil))) thesound))) (load-port-info newobj (quote nil)) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj "easy-out-8.aiff") (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (outport inport player zoom grillestep mode winsize winpos show-spectrum deltapict obj-mode cmnpref notechancolor? show-stems scale)) (list nil nil (quote :libaudiostream) 1 nil 0 (om-make-point 370 280) (om-make-point 400 20) nil (om-make-point 0 0) 0 (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) nil (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "RESULT" (quote om-darwin::result) (quote ((om-load-inputfun (quote input-funbox) "GA-ENGINE" "GA-ENGINE" nil))) (om-make-point 622 589) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "OM-CHOOSE-DIRECTORY-DIALOG" (quote om-choose-directory-dialog) (quote nil) (om-make-point 996 517) nil (list (om-make-pathname :directory (quote (:absolute "Users" "holbrook" "Data" "samples" "Contrabass" "artificial-harmonic")) :device :unspecific :host nil :name nil :type nil)) "x" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 1062 591) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-SAMPLER" (quote om-sampler) (quote ((om-load-inputfun (quote input-funbox) "" "OBJ" nil) (om-load-inputfun (quote input-funbox) "" "SOUND-LISTS" nil))) (om-make-point 934 672) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 147 19) (om-make-point 34 30) 24 "24" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "POPULATION" (quote om-darwin::population) (quote ((om-load-inputfun (quote input-funbox) "GA-ENGINE" "GA-ENGINE" nil))) (om-make-point 116 540) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CADAR" (quote cadar) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 182 601) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "GA-ENGINE" (quote om-darwin::ga-engine) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "" "model" nil) (om-load-inputfun (quote input-funbox) "" "fitness-function" nil))) (om-make-point 104 324) (om-make-point 667 156) (let ((om-darwin::ga (mki (quote om-darwin::ga-engine)))) (setf (om-darwin::model om-darwin::ga) (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype (list 129 50 62 159 238 88 195 51 185 111 189 21 243 17 75 87 159 53 230 103 240 35 132 75 142 150 119 217 114 217 72 98 63 212 40 76 135 42 217 26 168 144 94 178 22 205 242 84 104 147 23 231 121 188 4 73 141 153) :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) (list 129 50 62 159 238 88 195 51 185 111 189 21 243 17 75 87 159 53 230 103 240 35 132 75 142 150 119 217 114 217 72 98 63 212 40 76 135 42 217 26 168 144 94 178 22 205 242 84 104 147 23 231 121 188 4 73 141 153)) (om-darwin::update om-darwin::spec) om-darwin::spec)) (setf (om-darwin::population om-darwin::ga) (list (list 0 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype (list 230 170 78 168 23 7 189 230 8 233 238 244 93 181 13 18 106 251 230 17 220 143 253 205 35 10 172 96 150 86 241 166 8 218 91 94 232 164 172 235 184 251 235 147 178 172 45 56 10 82 140 178 40 3 117 239 97 148) :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) (list 230 170 78 168 23 7 189 230 8 233 238 244 93 181 13 18 106 251 230 17 220 143 253 205 35 10 172 96 150 86 241 166 8 218 91 94 232 164 172 235 184 251 235 147 178 172 45 56 10 82 140 178 40 3 117 239 97 148)) (om-darwin::update om-darwin::spec) om-darwin::spec) 0) (list 0 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype (list 134 214 82 94 48 126 61 236 25 4 224 130 133 217 67 178 195 114 135 206 187 192 13 172 47 87 237 84 80 200 125 217 192 98 145 80 214 145 199 31 72 69 140 109 33 182 130 254 177 71 97 152 180 241 130 84 208 181) :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) (list 134 214 82 94 48 126 61 236 25 4 224 130 133 217 67 178 195 114 135 206 187 192 13 172 47 87 237 84 80 200 125 217 192 98 145 80 214 145 199 31 72 69 140 109 33 182 130 254 177 71 97 152 180 241 130 84 208 181)) (om-darwin::update om-darwin::spec) om-darwin::spec) 0) (list 0 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype (list 45 204 151 65 85 12 7 109 47 194 142 242 123 15 244 34 95 232 137 109 183 221 181 113 75 50 69 128 242 23 9 126 168 205 9 106 107 229 157 143 165 197 166 34 225 44 61 191 151 97 254 2 139 38 171 118 100 74) :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) (list 45 204 151 65 85 12 7 109 47 194 142 242 123 15 244 34 95 232 137 109 183 221 181 113 75 50 69 128 242 23 9 126 168 205 9 106 107 229 157 143 165 197 166 34 225 44 61 191 151 97 254 2 139 38 171 118 100 74)) (om-darwin::update om-darwin::spec) om-darwin::spec) 0) (list 0 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype (list 200 103 155 114 127 136 82 36 112 3 84 252 220 142 122 163 111 210 193 88 183 43 235 119 7 197 196 2 36 136 228 199 219 231 191 225 217 159 9 61 35 53 164 107 189 75 17 44 119 5 79 154 183 174 143 68 130 51) :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) (list 200 103 155 114 127 136 82 36 112 3 84 252 220 142 122 163 111 210 193 88 183 43 235 119 7 197 196 2 36 136 228 199 219 231 191 225 217 159 9 61 35 53 164 107 189 75 17 44 119 5 79 154 183 174 143 68 130 51)) (om-darwin::update om-darwin::spec) om-darwin::spec) 0) (list 0 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype (list 66 141 126 166 79 240 110 189 8 147 19 133 28 176 221 219 118 73 123 50 4 82 224 91 67 218 92 116 27 142 148 109 76 24 130 109 72 158 60 89 85 137 110 137 165 246 118 81 216 11 184 168 12 58 190 62 136 65) :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) (list 66 141 126 166 79 240 110 189 8 147 19 133 28 176 221 219 118 73 123 50 4 82 224 91 67 218 92 116 27 142 148 109 76 24 130 109 72 158 60 89 85 137 110 137 165 246 118 81 216 11 184 168 12 58 190 62 136 65)) (om-darwin::update om-darwin::spec) om-darwin::spec) 0) (list 0 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype (list 31 91 170 53 195 17 108 160 75 136 150 67 175 46 212 103 109 169 133 206 151 158 55 145 42 90 177 25 97 167 161 138 25 243 62 43 99 63 21 154 219 226 35 240 175 232 167 223 128 47 41 80 166 141 169 118 157 117) :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) (list 31 91 170 53 195 17 108 160 75 136 150 67 175 46 212 103 109 169 133 206 151 158 55 145 42 90 177 25 97 167 161 138 25 243 62 43 99 63 21 154 219 226 35 240 175 232 167 223 128 47 41 80 166 141 169 118 157 117)) (om-darwin::update om-darwin::spec) om-darwin::spec) 0) (list 0 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype (list 105 169 111 29 231 142 12 38 186 17 19 61 26 217 199 62 169 241 79 58 37 215 7 52 10 122 230 21 118 44 207 220 213 77 1 198 78 89 202 112 80 104 96 233 211 65 179 93 23 29 71 128 188 30 175 222 101 242) :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) (list 105 169 111 29 231 142 12 38 186 17 19 61 26 217 199 62 169 241 79 58 37 215 7 52 10 122 230 21 118 44 207 220 213 77 1 198 78 89 202 112 80 104 96 233 211 65 179 93 23 29 71 128 188 30 175 222 101 242)) (om-darwin::update om-darwin::spec) om-darwin::spec) 0) (list 0 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype (list 235 210 26 32 67 151 0 247 174 18 239 225 53 192 70 122 129 96 162 88 82 252 221 169 31 24 88 35 36 38 249 47 47 57 21 9 225 193 220 65 17 244 87 185 105 236 131 166 9 218 219 255 185 70 28 1 85 55) :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) (list 235 210 26 32 67 151 0 247 174 18 239 225 53 192 70 122 129 96 162 88 82 252 221 169 31 24 88 35 36 38 249 47 47 57 21 9 225 193 220 65 17 244 87 185 105 236 131 166 9 218 219 255 185 70 28 1 85 55)) (om-darwin::update om-darwin::spec) om-darwin::spec) 0) (list 0 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype (list 194 147 166 198 150 181 31 19 23 8 50 64 254 214 220 228 244 71 29 143 49 16 187 152 77 170 122 107 177 235 162 181 60 117 173 135 143 126 175 186 12 243 75 43 33 82 236 134 165 167 89 164 22 107 121 209 27 117) :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) (list 194 147 166 198 150 181 31 19 23 8 50 64 254 214 220 228 244 71 29 143 49 16 187 152 77 170 122 107 177 235 162 181 60 117 173 135 143 126 175 186 12 243 75 43 33 82 236 134 165 167 89 164 22 107 121 209 27 117)) (om-darwin::update om-darwin::spec) om-darwin::spec) 0) (list 0 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype (list 148 161 155 97 98 247 202 161 83 31 236 9 74 152 15 214 63 117 174 198 183 79 11 89 118 70 244 194 115 200 128 27 119 68 97 177 82 199 175 139 75 187 237 194 138 71 170 117 50 175 26 223 194 0 168 225 237 165) :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) (list 148 161 155 97 98 247 202 161 83 31 236 9 74 152 15 214 63 117 174 198 183 79 11 89 118 70 244 194 115 200 128 27 119 68 97 177 82 199 175 139 75 187 237 194 138 71 170 117 50 175 26 223 194 0 168 225 237 165)) (om-darwin::update om-darwin::spec) om-darwin::spec) 0))) (setf (om-darwin::generation om-darwin::ga) 0) (setf (om-darwin::result om-darwin::ga) (if (find-class (quote poly) nil) (let ((newobj (make-instance (quote poly) :voices (list (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (5 (((1 8) (1)) ((1 8) (1.0)) ((17 8) (6.0 1 1 1 1 1 1 1 1 3)) ((17 8) (4.0 1 1 1 1 1 1 1 3 1 1 1)) ((1 8) (1)) ((1 8) (1.0)) ((1 8) (1)) ((1 8) (-1))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6100)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (4000)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7150)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (4500)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6650)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5700)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7150)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6150)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6650)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7650)) :ldur (quote (1500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5200)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6900)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5700)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5900)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6200)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5200)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5200)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5600)) :ldur (quote (1500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7650)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6600)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5200)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6900)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5900)) :ldur (quote (500)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord)))) :tempo (quote ((1/4 60) nil)) :legato 100 :ties (quote (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote nil)) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote (nil))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))) om-darwin::ga) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 4 24 (list (quote gf)) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :midi-player) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 400 20) 0 1 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 2 0 nil 0) (12 0 3 0 nil 0) (1 0 3 1 nil 0) (6 0 5 0 nil 0) (14 0 6 0 nil 0) (11 0 7 0 nil 0) (15 0 8 0 nil 0) (9 0 10 0 nil 0) (8 0 11 0 nil 0) (10 0 11 1 nil 0) (15 0 13 0 nil 0) (13 0 14 0 nil 0) (2 0 15 1 nil 0))) nil 6.1))
