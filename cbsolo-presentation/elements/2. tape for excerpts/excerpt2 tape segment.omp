; OM File Header - Saved 2015/06/21 19:57:54
; (6.1 :patc (om-make-point 10 10) (om-make-point 158 193) (om-make-point 1412 1221) "" 183 0 "2015/06/21 17:58:22" "2015/06/21 19:57:54")
; End File Header
; External resources 
; (list (list (quote :abstraction) "#P\"../more csound/convolve.omp\"") (list (quote :instance) "#P\"../../globals/2d corpus periodicity db.omi\"" "#P\"../../globals/pp first file midic.omi\"" "#P\"../../globals/2D PP CSEQ ANALYSIS.omi\"" "#P\"../../globals/2d pp path list.omi\""))
(in-package :om)(load-lib-for (quote ("om-geof" "om-darwin" "om4csound")))(setf *om-current-persistent* (om-load-patch1 "excerpt2 tape segment" (quote ((let ((box (om-load-boxcall (quote genfun) "JOIN_SOUNDFILES" (quote om-auro::join_soundfiles) (quote ((om-load-inputfun (quote input-funbox) "" "LISTA" nil))) (om-make-point 489 1078) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 556 1005) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SPLIT_SOUNDFILE" (quote om-auro::split_soundfile) (quote ((om-load-inputfun (quote input-funbox) "" "SND" nil))) (om-make-point 298 918) (om-make-point 145 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "generations" 4 (om-make-point 404 560) "" "generations" 50 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "shift-to-zero" (om-load-lisp-abspatch "shift-to-zero" 6.1 ";;; Edit a valid LAMBDA EXPRESSION for \"shift-to-zero\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (arr)$  (d::arr-time-shift arr (- (d::arr-start arr))))") (quote ((om-load-inputfun (quote input-funbox) "" "ARR" nil))) (om-make-point 421 84) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "test" (om-load-patch-abs1 "test" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 319 210) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 54 124) (om-make-point 27 30) 6 "6" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FIRST-N" (quote first-n) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" 6) (om-load-inputfun (quote input-funbox) "number of elements" "N" 0))) (om-make-point 144 188) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxinstance "CB PART" (let ((copy (make-instance (quote omlistinstance) :name "CB PART" :icon 129))) (setf (instance copy) (list (quote :header) (list (quote :time-sig) (list (list 9 8) (list 9 8) (list 4 4) (list 7 8) (list 4 4) (list 7 8) (list 3 4))) (list 0 3/16 1 4200) (list 3/16 3/16 1 3900) (list 3/8 3/16 1 3600) (list 9/16 3/16 1 3300) (list 3/4 3/16 1 3100) (list 15/16 3/16 1 2800) (list 9/8 3/16 1 4600) (list 21/16 3/16 1 4000) (list 3/2 3/16 1 3500) (list 27/16 3/16 1 4300) (list 15/8 1/8 1 3800) (list 2 1/4 1 4500) (list 9/4 1/8 1 5000) (list 19/8 3/16 1 4000) (list 41/16 3/16 1 3600) (list 11/4 1/8 1 4200) (list 23/8 3/16 1 3700) (list 49/16 3/16 1 4300) (list 13/4 1/8 1 5300) (list 27/8 3/16 1 4300) (list 57/16 1/8 1 3800) (list 59/16 3/16 1 4500) (list 31/8 1/8 1 4000) (list 4 1/8 1 4900) (list 33/8 3/16 1 5600) (list 69/16 3/16 1 4600) (list 9/2 1/8 1 4200) (list 37/8 3/16 1 5000) (list 77/16 1/8 1 4300) (list 79/16 3/16 1 5200) (list 41/8 1/8 1 5900) (list 21/4 1/8 1 5700) (list 43/8 3/16 1 5500) (list 89/16 1/8 1 5200) (list 91/16 1/8 1 4900) (list 93/16 3/16 1 4600) (list 6 1/8 1 6200) (list 49/8 1/8 1 5600) (list 25/4 1/8 1 5200) (list 51/8 1/8 1 5700) (list 13/2 1/8 1 5300) (list 53/8 1/8 1 5900))) (setf (edition-params copy) (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40)))) (setf (create-info copy) (quote (nil "2015/06/21 19:57:52"))) (setf (doc copy) (str-with-nl "")) copy) (quote nil) (om-make-point 50 50) nil (om-make-point 45 40)))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ARR-REGIONS" (quote om-darwin::arr-regions) (quote ((om-load-inputfun (quote input-funbox) "ARR" "ARR" nil))) (om-make-point 128 125) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (4 0 2 0 nil 0) (1 0 2 1 nil 0) (3 0 4 0 nil 0))) 6.1 nil "" (om-make-point 200 200) (om-make-point 444 335)) (quote nil) (om-make-point 610 24) nil nil nil "test"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "CONDITIONAL 2" (quote conditional) (quote ((om-load-inputfun (quote input-funbox) "test" "TEST" nil) (om-load-inputfun (quote input-funbox) "add-test" "ADDTEST" (quote t)))) (om-make-point 543 141) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "EVOLUTE" (quote evolute) (quote ((om-load-inputfun (quote input-funbox) "" "MODEL" nil) (om-load-inputfun (quote input-funbox) "" "CRITERION" nil) (om-load-inputfun (quote input-funbox) "" "GENERATIONS" 100))) (om-make-point 233 696) (om-make-point 146 67) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 317 1051) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "IR MIX" 3 (om-make-point 704 777) "" "IR MIX" 0.3 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "CONDITIONAL" (quote conditional) (quote ((om-load-inputfun (quote input-funbox) "test" "TEST" nil) (om-load-inputfun (quote input-funbox) "add-test" "ADDTEST" (quote t)))) (om-make-point 793 633) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "IR path" 2 (om-make-point 792 538) "" "IR path" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "periodicity" 1 (om-make-point 831 194) "" "periodicity" (list 0.5 0.7) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "CB segment" 0 (om-make-point 319 13) "" "CB segment" (list 0 6) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "periodicity" (om-load-patch-abs1 "periodicity" (quote ((let ((box (om-load-boxin "input" 0 (om-make-point 118 157) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 197 667) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "C-PITCH" (quote c-pitch) (quote ((om-load-inputfun (quote input-funbox) "" "TEST-VALUE" nil))) (om-make-point 125 377) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxinstance "2d corpus periodicity db" (get-inst-from-globals "2d corpus periodicity db") (quote nil) (om-make-point 298 78) nil (om-make-point 154 59)))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ARR-PROCESS-PITCHES" (quote om-darwin::arr-process-pitches) (quote ((om-load-inputfun (quote input-funbox) "ARR" "ARR" nil) (om-load-inputfun (quote input-funbox) "FUN" "FUN" nil))) (om-make-point 234 426) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "corpus def->periodicity" (om-load-patch-abs1 "corpus def->periodicity" (quote ((let ((box (om-load-boxcall (quote lispfun) "1-" (quote 1-) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 523 297) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MOD" (quote mod) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil) (om-load-inputfun (quote input-funbox) "Y" "Y" nil))) (om-make-point 445 417) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 462 249) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH 2" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 327 211) (om-make-point 79 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 167 487) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 91 411) (om-make-point 104 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 132 217) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 199 117) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "db" 1 (om-make-point 463 55) "" "db" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "def" 0 (om-make-point 195 21) "" "def" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 257 738) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (6 1 1 0 nil 0) (0 0 1 1 nil 0) (3 0 2 0 nil 0) (6 0 3 0 nil 0) (8 0 3 1 nil 0) (5 0 4 0 nil 0) (1 0 5 0 nil 0) (3 0 5 1 nil 0) (7 0 6 0 nil 0) (9 0 7 0 nil 0) (4 0 10 0 nil 0))) 6.1 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "def" nil) (om-load-inputfun (quote input-funbox) "" "db" nil))) (om-make-point 220 295) nil (list nil) "l" "corpus def->periodicity"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "WITH-PHENO" (quote with-pheno) (quote ((om-load-inputfun (quote input-funbox) "" "EVALUATOR" nil) (om-load-inputfun (quote input-funbox) "" "SUBJECT" nil))) (om-make-point 157 540) (om-make-point 202 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 0 1 0 nil 0) (0 0 2 0 nil 0) (5 0 4 1 nil 0) (3 0 5 1 nil 0) (2 0 6 0 nil 0) (4 0 6 1 nil 0))) 6.1 nil "" (om-make-point 1393 231) (om-make-point 514 793)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 806 366) nil (list nil) nil "periodicity"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "C-LIST" (quote c-list) (quote ((om-load-inputfun (quote input-funbox) "" "CS" 0) (om-load-inputfun (quote input-funbox) "" "CS" 0))) (om-make-point 563 593) (om-make-point 160 67) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "WITH-PHENO" (quote with-pheno) (quote ((om-load-inputfun (quote input-funbox) "" "EVALUATOR" nil) (om-load-inputfun (quote input-funbox) "" "SUBJECT" nil))) (om-make-point 489 491) (om-make-point 180 67) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "OM-CHOOSE-FILE-DIALOG" (quote om-choose-file-dialog) (quote nil) (om-make-point 887 523) nil (list (om-make-pathname :directory (quote (:absolute "Users" "holbrook" "Data" "samples" "SPACE ECHO IR")) :device :unspecific :host :unspecific :name "Mode02" :type "aif")) "x" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "convolve" (quote ("elements" "more csound" "convolve")) (quote ((om-load-inputfun (quote input-funbox) "" "sound" nil) (om-load-inputfun (quote input-funbox) "" "impulse" nil) (om-load-inputfun (quote input-funbox) "" "mix" nil))) (om-make-point 514 861) (om-make-point 121 67) (list "/Users/holbrook/Desktop/out-files/easy-out-54.aiff") "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "map-register" (om-load-lisp-abspatch "map-register" 6.1 ";;; Edit a valid LAMBDA EXPRESSION for \"map-register\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (arr cb-arr)$  (let ((ranges (mapcar #'(lambda (centre)$                            (list (- centre 500)$                                  (+ centre 500)))$                        (om::om-scale (mapcar 'd::region-pitch (d::arr-regions cb-arr))$                                      2600 8000))))$    (loop for range in ranges$          for chord in (d::demix (d::arr-regions arr) #'d::region-start)$          sum (loop for reg in chord$                    sum (d::offby (d::region-pitch reg)$                                  range)))))$                        ") (quote ((om-load-inputfun (quote input-funbox) "" "ARR" nil) (om-load-inputfun (quote input-funbox) "" "CB-ARR" nil))) (om-make-point 471 341) (om-make-point 128 67) (list nil) "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ARR-PROCESS-PITCHES" (quote om-darwin::arr-process-pitches) (quote ((om-load-inputfun (quote input-funbox) "ARR" "ARR" nil) (om-load-inputfun (quote input-funbox) "FUN" "FUN" nil))) (om-make-point 642 382) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "manual def->pitch" (om-load-patch-abs1 "manual def->pitch" (quote ((let ((box (om-load-boxcall (quote abstraction) "get-interval" (om-load-lisp-abspatch "get-interval" 6.1 ";;; Edit a valid LAMBDA EXPRESSION for \"get-interval\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (folder-index)$  (if (or (= folder-index 11)$          (= folder-index 12))$      100$    300))") (quote ((om-load-inputfun (quote input-funbox) "" "FOLDER-INDEX" nil))) (om-make-point 584 362) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MOD" (quote mod) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil) (om-load-inputfun (quote input-funbox) "Y" "Y" nil))) (om-make-point 424 359) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH 2" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 395 201) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 193 469) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 431 263) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 300))) (om-make-point 342 500) (om-make-point 65 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 78 368) (om-make-point 104 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxinstance "pp first file midic" (get-inst-from-globals "pp first file midic") (quote nil) (om-make-point 29 129) nil (om-make-point 45 40)))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 155 230) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "+" (quote +) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 155 573) (om-make-point 386 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 218 132) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "db" 1 (om-make-point 463 55) "" "db" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "def" 0 (om-make-point 213 28) "" "def" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 241 702) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((8 0 0 0 nil 2) (8 1 1 0 nil 0) (4 0 1 1 nil 0) (8 0 2 0 nil 0) (11 0 2 1 nil 0) (6 0 3 0 nil 0) (2 0 4 0 nil 0) (1 0 5 0 nil 0) (0 0 5 1 nil 2) (8 0 6 0 nil 0) (7 0 6 1 nil 0) (10 0 8 0 nil 0) (3 0 9 0 nil 0) (5 0 9 1 nil 0) (10 1 9 2 nil 0) (12 0 10 0 nil 0) (9 0 13 0 nil 0))) 6.1 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "def" nil) (om-load-inputfun (quote input-funbox) "" "db" nil))) (om-make-point 685 281) nil (list nil) "l" "manual def->pitch"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "combine for display" (om-load-patch-abs1 "combine for display" (quote ((let ((box (om-load-boxcall (quote lispfun) "ARR-SET-CHANNEL" (quote om-darwin::arr-set-channel) (quote ((om-load-inputfun (quote input-funbox) "ARR" "ARR" nil) (om-load-inputfun (quote input-funbox) "CHAN" "CHAN" nil))) (om-make-point 355 178) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 456 133) (om-make-point 27 30) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ARR-HEADER" (quote om-darwin::arr-header) (quote ((om-load-inputfun (quote input-funbox) "ARR" "ARR" nil))) (om-make-point 95 402) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "APPEND 2" (quote append) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 132 464) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ARR-REGIONS" (quote om-darwin::arr-regions) (quote ((om-load-inputfun (quote input-funbox) "ARR" "ARR" nil))) (om-make-point 348 238) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARRANGE->POLY" (quote om-darwin::arrange->poly) (quote ((om-load-inputfun (quote input-funbox) "" "ARR" nil))) (om-make-point 60 518) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 103 628) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 3" 2 (om-make-point 357 26) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "db" 1 (om-make-point 204 16) "" "db" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "pheno" 0 (om-make-point 88 129) "" "pheno" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ARR-REGIONS" (quote om-darwin::arr-regions) (quote ((om-load-inputfun (quote input-funbox) "ARR" "ARR" nil))) (om-make-point 203 300) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "APPEND" (quote append) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 303 372) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ARR-PROCESS-PITCHES" (quote om-darwin::arr-process-pitches) (quote ((om-load-inputfun (quote input-funbox) "ARR" "ARR" nil) (om-load-inputfun (quote input-funbox) "FUN" "FUN" nil))) (om-make-point 84 240) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "manual def->pitch" (om-load-patch-abs1 "manual def->pitch" (quote ((let ((box (om-load-boxcall (quote abstraction) "get-interval" (om-load-lisp-abspatch "get-interval" 6.1 ";;; Edit a valid LAMBDA EXPRESSION for \"get-interval\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (folder-index)$  (if (or (= folder-index 11)$          (= folder-index 12))$      100$    300))") (quote ((om-load-inputfun (quote input-funbox) "" "FOLDER-INDEX" nil))) (om-make-point 584 362) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MOD" (quote mod) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil) (om-load-inputfun (quote input-funbox) "Y" "Y" nil))) (om-make-point 424 359) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH 2" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 395 201) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 193 469) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 431 263) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 300))) (om-make-point 342 500) (om-make-point 65 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 78 368) (om-make-point 104 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxinstance "pp first file midic" (get-inst-from-globals "pp first file midic") (quote nil) (om-make-point 29 129) nil (om-make-point 45 40)))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 155 230) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "+" (quote +) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 155 573) (om-make-point 386 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 218 132) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "db" 1 (om-make-point 463 55) "" "db" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "def" 0 (om-make-point 143 15) "" "def" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 241 702) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((8 0 0 0 nil 2) (8 1 1 0 nil 0) (4 0 1 1 nil 0) (8 0 2 0 nil 0) (11 0 2 1 nil 0) (6 0 3 0 nil 0) (2 0 4 0 nil 0) (1 0 5 0 nil 0) (0 0 5 1 nil 2) (8 0 6 0 nil 0) (7 0 6 1 nil 0) (10 0 8 0 nil 0) (3 0 9 0 nil 0) (5 0 9 1 nil 0) (10 1 9 2 nil 0) (12 0 10 0 nil 0) (9 0 13 0 nil 0))) 6.1 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "def" nil) (om-load-inputfun (quote input-funbox) "" "db" nil))) (om-make-point 189 132) nil (list nil) "l" "manual def->pitch"))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((7 0 0 0 nil 0) (1 0 0 1 nil 0) (7 0 2 0 nil 0) (2 0 3 0 nil 0) (11 0 3 1 nil 0) (0 0 4 0 nil 0) (3 0 5 0 nil 0) (5 0 6 0 nil 0) (12 0 10 0 nil 0) (10 0 11 0 nil 0) (4 0 11 1 nil 0) (9 0 12 0 nil 0) (13 0 12 1 nil 0) (8 0 13 1 nil 0))) 6.1 nil "" (om-make-point 336 303) (om-make-point 524 720)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil) (om-load-inputfun (quote input-funbox) "" "input 3" nil))) (om-make-point 292 340) (om-make-point 135 67) (list nil) "l" "combine for display"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "sample id and detune" (om-load-patch-abs1 "sample id and detune" (quote ((let ((box (om-load-boxin "input" 2 (om-make-point 802 304) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "N" 0))) (om-make-point 466 695) (om-make-point 109 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "COMBINE-RHYTHMS-AND-PITCHES" (quote om-darwin::combine-rhythms-and-pitches) (quote ((om-load-inputfun (quote input-funbox) "RHYTHM-ARR" "RHYTHM-ARR" nil) (om-load-inputfun (quote input-funbox) "PITCHES" "PITCHES" nil))) (om-make-point 696 688) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REDUCE" (quote reduce) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 620 887) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "PILE-ARRANGEMENTS" (quote om-darwin::pile-arrangements) (quote ((om-load-inputfun (quote input-funbox) "ARR1" "ARR1" nil) (om-load-inputfun (quote input-funbox) "ARR2" "ARR2" nil))) (om-make-point 486 810) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 676 791) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 5" (quote t) (quote nil) (om-make-point 607 636) (om-make-point 27 30) 4 "4" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "N" 0))) (om-make-point 456 603) (om-make-point 109 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 524 512) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 100 60) (quote "sample identifier") "" (om-make-point 148 427) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 2" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 223 426) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-GENE" (quote om-gene) (quote ((om-load-inputfun (quote input-funbox) "minimum value" "MIN" 0) (om-load-inputfun (quote input-funbox) "maximum value" "MAX" 1))) (om-make-point 261 299) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "1-" (quote 1-) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 292 217) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 241 257) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 105 263) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "1-" (quote 1-) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 156 223) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-GENE" (quote om-gene) (quote ((om-load-inputfun (quote input-funbox) "minimum value" "MIN" 0) (om-load-inputfun (quote input-funbox) "maximum value" "MAX" 1))) (om-make-point 125 305) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "max-folder-length" 1 (om-make-point 358 33) "" "max-folder-length" 16 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 75 44) (quote "detune in midicents") "" (om-make-point 512 350) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 548 240) (om-make-point 34 30) 50 "50" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 10) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 460 353) (om-make-point 46 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 513 154) (om-make-point 27 30) 3 "3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 408 159) (om-make-point 32 30) -3 "-3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-GENE" (quote om-gene) (quote ((om-load-inputfun (quote input-funbox) "minimum value" "MIN" 0) (om-load-inputfun (quote input-funbox) "maximum value" "MAX" 1))) (om-make-point 430 246) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 787 905) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "num-folders" 0 (om-make-point 108 29) "" "num-folders" 255 (om-make-point 107 59)))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 372 506) (om-make-point 84 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((7 0 1 0 nil 0) (6 0 1 1 nil 0) (0 0 2 0 nil 0) (4 0 3 0 nil 0) (5 0 3 1 nil 0) (2 0 5 0 nil 0) (1 0 5 1 nil 0) (26 0 7 0 nil 0) (8 0 7 1 nil 0) (0 0 8 0 nil 0) (16 0 10 0 nil 0) (11 0 10 1 nil 0) (13 0 11 0 nil 0) (12 0 11 1 nil 0) (17 0 12 0 nil 0) (25 0 15 0 nil 0) (14 0 16 0 nil 0) (15 0 16 1 nil 0) (23 0 20 0 nil 0) (19 0 20 1 nil 0) (22 0 23 0 nil 0) (21 0 23 1 nil 0) (3 0 24 0 nil 0) (10 0 26 0 nil 0) (20 0 26 1 nil 0))) 6.1 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "num-folders" nil) (om-load-inputfun (quote input-funbox) "" "max-folder-length" nil) (om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 67 337) (om-make-point 163 67) (list nil) "l" "sample id and detune"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DEFINE-SPECIES" (quote define-species) (quote ((om-load-inputfun (quote input-funbox) "" "FUN" nil) (om-load-inputkeyword (quote input-keyword) "" "finalizer" (quote :finalizer) nil nil))) (om-make-point 159 440) (om-make-point 237 67) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 42 227) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "defs->sound" (om-load-patch-abs1 "defs->sound" (quote ((let ((box (om-load-boxcall (quote abstraction) "jitter" (om-load-lisp-abspatch "jitter" 6.1 ";;; Edit a valid LAMBDA EXPRESSION for \"jitter\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (times)$  (loop for time in times$        collect (+ time (* (om-random -20 20) .001))))$  ") (quote ((om-load-inputfun (quote input-funbox) "" "TIMES" nil))) (om-make-point 278 385) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "get values of best specimen" (om-load-patch-abs1 "get values of best specimen" (quote ((let ((box (om-load-boxout "output 2" 1 (om-make-point 350 488) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 67 500) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 52 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "PHENOTYPE" (quote om-darwin::phenotype) (quote ((om-load-inputfun (quote input-funbox) "SELF" "SELF" nil))) (om-make-point 71 135) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 27 372) (om-make-point 108 59) nil nil nil 4))) (setf (numouts box) 4) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 26 285) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ARR-REGIONS" (quote om-darwin::arr-regions) (quote ((om-load-inputfun (quote input-funbox) "ARR" "ARR" nil))) (om-make-point 40 217) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((4 3 0 0 nil 0) (4 0 1 0 nil 0) (2 0 3 0 nil 0) (5 0 4 0 nil 0) (6 0 5 0 nil 0) (3 0 6 0 nil 0))) 6.1 nil "" (om-make-point 697 257) (om-make-point 460 637)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 195 116) nil nil nil "get values of best specimen"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "def->soundpath" (om-load-patch-abs1 "def->soundpath" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 107 840) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "db" 1 (om-make-point 380 187) "" "db" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "def" 0 (om-make-point 100 73) "" "def" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 95 727) (om-make-point 67 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 57 290) (om-make-point 132 59) nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MOD" (quote mod) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil) (om-load-inputfun (quote input-funbox) "Y" "Y" nil))) (om-make-point 232 609) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 259 550) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 76 474) (om-make-point 67 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 0 0 nil 0) (5 0 3 0 nil 0) (7 0 3 1 nil 0) (2 0 4 0 nil 0) (4 1 5 0 nil 0) (6 0 5 1 nil 0) (7 0 6 0 nil 0) (4 0 7 0 nil 0) (1 0 7 1 nil 0))) 6.1 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 60 288) nil nil "l" "def->soundpath"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 290 213) (om-make-point 34 30) 80 "80" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "ratios-to-ms" (om-load-lisp-abspatch "ratios-to-ms" 6.1 ";;; Edit a valid LAMBDA EXPRESSION for \"ratios-to-ms\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (ratios tempo)$  (om* ratios (* (/ 60 tempo) 4)))") (quote ((om-load-inputfun (quote input-funbox) "" "RATIOS" nil) (om-load-inputfun (quote input-funbox) "" "TEMPO" nil))) (om-make-point 212 271) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 389 372) (om-make-point 132 59) nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 439 279) (om-make-point 93 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 238 607) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "db" 1 (om-make-point 126 212) "" "db" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "engine" 0 (om-make-point 188 28) "" "engine" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "PLACE-SOUNDS" (quote place-sounds) (quote ((om-load-inputfun (quote input-funbox) "" "SOUNDS" nil) (om-load-inputfun (quote input-funbox) "" "TIMES-1" nil) (om-load-inputfun (quote input-funbox) "" "DETUNES" nil))) (om-make-point 215 508) (om-make-point 114 67) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 94 418) (om-make-point 81 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((4 0 0 0 nil 0) (9 0 1 0 nil 0) (8 0 2 1 nil 0) (1 0 4 0 nil 0) (3 0 4 1 nil 0) (6 0 5 0 nil 0) (1 1 6 0 nil 0) (10 0 7 0 nil 0) (11 0 10 0 nil 0) (0 0 10 1 nil 0) (5 1 10 2 nil 0) (2 0 11 0 nil 0) (5 0 11 1 nil 0))) 6.1 nil "" (om-make-point 200 200) (om-make-point 1007 713)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 374 794) nil (list "/Users/holbrook/Desktop/out-files/easy-out-53.aiff") nil "defs->sound"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "biggest-folder" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 112 219) nil nil nil (list (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 173 261) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "max" (quote maxi) (quote ((om-load-inputfun (quote input-funbox) "numbers" "VALUE" nil))) (om-make-point 154 344) (om-make-point 133 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 154 165) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 164 60) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 239 471) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 139 471) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (0 0 1 0 nil 0) (3 0 2 0 nil 0) (1 1 4 0 nil 0) (1 0 5 0 nil 0))) 1 "biggest-folder" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxinstance "2D PP CSEQ ANALYSIS" (get-inst-from-globals "2D PP CSEQ ANALYSIS") (quote nil) (om-make-point 84 77) nil (om-make-point 171 59)))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxinstance "2d pp path list" (get-inst-from-globals "2d pp path list") (quote nil) (om-make-point 474 702) nil (om-make-point 130 59)))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (18 0 1 0 nil 0) (2 0 1 1 nil 0) (26 0 2 0 nil 0) (13 0 4 0 nil 0) (4 0 6 0 nil 0) (5 0 6 1 nil 0) (24 0 7 0 nil 0) (15 0 7 1 nil 0) (3 0 7 2 nil 0) (0 0 8 0 nil 0) (11 0 10 0 nil 0) (17 0 10 1 nil 0) (12 0 14 0 nil 0) (16 0 15 0 nil 0) (14 0 15 1 nil 0) (19 0 16 0 nil 0) (20 0 16 1 nil 0) (10 0 18 1 nil 0) (9 0 18 2 nil 0) (6 0 19 1 nil 10) (21 0 20 1 nil 0) (28 0 21 1 nil 0) (28 0 22 1 nil 0) (6 0 22 2 nil 10) (25 0 23 0 nil 0) (27 0 23 1 nil 0) (6 0 23 2 nil 10) (23 0 24 0 nil 0) (22 0 24 1 nil 0) (28 0 25 0 nil 3) (7 0 26 0 nil 0) (29 0 26 1 nil 0) (28 0 27 0 nil 3))) nil 6.1))