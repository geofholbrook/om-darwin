; OM File Header - Saved 2015/06/12 18:11:51
; (6.1 :patc (om-make-point 10 10) (om-make-point 677 22) (om-make-point 1293 1273) "" 183 0 "2015/06/12 17:34:06" "2015/06/12 18:11:51")
; End File Header
; External resources 
; (list (list (quote :sound) "#P\"../out-files/easy-out-422.aiff\"") (list (quote :instance) "#P\"../globals/pp first file midic.omi\"" "#P\"../globals/2D PP CSEQ ANALYSIS.omi\""))
(in-package :om)(load-lib-for (quote ("om-geof" "om-darwin")))(setf *om-current-persistent* (om-load-patch1 "PP chords" (quote ((let ((box (om-load-boxcall (quote abstraction) "manual def->pitch" (om-load-patch-abs1 "manual def->pitch" (quote ((let ((box (om-load-boxcall (quote abstraction) "get-interval" (om-load-lisp-abspatch "get-interval" 6.1 ";;; Edit a valid LAMBDA EXPRESSION for \"get-interval\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (folder-index)$  (if (or (= folder-index 11)$          (= folder-index 12))$      100$    300))") (quote ((om-load-inputfun (quote input-funbox) "" "FOLDER-INDEX" nil))) (om-make-point 636 380) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MOD" (quote mod) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil) (om-load-inputfun (quote input-funbox) "Y" "Y" nil))) (om-make-point 424 359) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH 2" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 395 201) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 193 469) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 431 263) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 300))) (om-make-point 342 500) (om-make-point 65 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 78 368) (om-make-point 104 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxinstance "pp first file midic" (get-inst-from-globals "pp first file midic") (quote nil) (om-make-point 29 129) nil (om-make-point 45 40)))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 155 230) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "+" (quote +) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 155 573) (om-make-point 386 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 218 132) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "db" 1 (om-make-point 463 55) "" "db" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "def" 0 (om-make-point 143 15) "" "def" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 241 702) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((8 0 0 0 nil 2) (8 1 1 0 nil 0) (4 0 1 1 nil 0) (8 0 2 0 nil 0) (11 0 2 1 nil 0) (6 0 3 0 nil 0) (2 0 4 0 nil 0) (1 0 5 0 nil 0) (0 0 5 1 nil 2) (8 0 6 0 nil 0) (7 0 6 1 nil 0) (10 0 8 0 nil 0) (3 0 9 0 nil 0) (5 0 9 1 nil 0) (10 1 9 2 nil 0) (12 0 10 0 nil 0) (9 0 13 0 nil 0))) 6.1 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "def" nil) (om-load-inputfun (quote input-funbox) "" "db" nil))) (om-make-point 559 146) nil (list nil) "l" "manual def->pitch"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ARR-PROCESS-PITCHES" (quote om-darwin::arr-process-pitches) (quote ((om-load-inputfun (quote input-funbox) "ARR" "ARR" nil) (om-load-inputfun (quote input-funbox) "FUN" "FUN" nil))) (om-make-point 1087 456) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 118 211) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 154 77) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAAR" (quote caar) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 75 117) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REGION-PITCH" (quote om-darwin::region-pitch) (quote ((om-load-inputfun (quote input-funbox) "REGION" "REGION" nil))) (om-make-point 50 50) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (3 0 2 0 nil 0) (1 0 3 0 nil 0))) 6.1 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 515 307) nil (list nil) "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 5" (quote t) (quote nil) (om-make-point 753 304) (om-make-point 27 30) 5 "5" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "EVALUATE" (quote evaluate) (quote ((om-load-inputfun (quote input-funbox) "" "SPEC" nil) (om-load-inputfun (quote input-funbox) "" "CRITERION" nil))) (om-make-point 525 494) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (let ((newbox (omng-make-new-boxcall (quote dead) (om-make-point 572 843) "2d pp path list"))) (setf (mesage newbox) "This box was an instance; now it is dead forever.") newbox))) (setf (frame-position newbox) (om-make-point 572 843)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxinstance "2D PP CSEQ ANALYSIS" (get-inst-from-globals "2D PP CSEQ ANALYSIS") (quote nil) (om-make-point 365 25) nil (om-make-point 45 40)))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "CRITERION" (quote criterion) (quote ((om-load-inputfun (quote input-funbox) "" "EVALUATOR" nil) (om-load-inputfunmenu1 (quote input-funmenu) "" "SUBJECT" (quote :regions) (list (list "regions" (quote :regions)) (list "adjacent" (quote :adjacent)) (list "nthcdr" (quote :nthcdr)) (list "pitch" (quote :pitch)) (list "pitch-class" (quote :pitch-class)) (list "melodic" (quote :melodic)) (list "signed-melodic" (quote :signed-melodic)))) (om-load-inputfun (quote input-funbox) "" "TEST-VALUE" nil) (om-load-inputfun (quote input-funbox) "" "RATE" nil))) (om-make-point 632 384) (om-make-point 162 67) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "C-MELODIC" (quote c-melodic) (quote ((om-load-inputfun (quote input-funbox) "" "TEST-VALUE" nil))) (om-make-point 928 450) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 885 1792/5) (om-make-point 75 30) (list 3600 nil) "(3600 nil)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "C-LIST" (quote c-list) (quote ((om-load-inputfun (quote input-funbox) "" "CS" nil) (om-load-inputfun (quote input-funbox) "" "CS" nil))) (om-make-point 662 2842/5) (om-make-point 215 67) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 120 912) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "biggest-folder" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 117 169) nil nil nil (list (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 173 261) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "max" (quote maxi) (quote ((om-load-inputfun (quote input-funbox) "numbers" "VALUE" nil))) (om-make-point 154 344) (om-make-point 133 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 154 165) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 164 60) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 239 471) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 139 471) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (0 0 1 0 nil 0) (3 0 2 0 nil 0) (1 1 4 0 nil 0) (1 0 5 0 nil 0))) 1 "biggest-folder" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "WITH-PHENO" (quote with-pheno) (quote ((om-load-inputfun (quote input-funbox) "" "EVALUATOR" nil) (om-load-inputfun (quote input-funbox) "" "SUBJECT" nil))) (om-make-point 933 629) (om-make-point 202 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SAVE-SOUND" (quote save-sound) (quote ((om-load-inputfun (quote input-funbox) "a sound or om-sound-data buffer" "SELF" nil) (om-load-inputfun (quote input-funbox) "output file pathname" "FILENAME" nil))) (om-make-point 914 1010) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 617 310) (om-make-point 67 30) (quote :regions) ":regions" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "defs->sound" (om-load-patch-abs1 "defs->sound" (quote ((let ((box (om-load-boxcall (quote abstraction) "def->soundpath" (om-load-patch-abs1 "def->soundpath" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 107 840) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "db" 1 (om-make-point 380 187) "" "db" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "def" 0 (om-make-point 100 73) "" "def" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 95 727) (om-make-point 67 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 57 290) (om-make-point 132 59) nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MOD" (quote mod) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil) (om-load-inputfun (quote input-funbox) "Y" "Y" nil))) (om-make-point 232 609) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 259 550) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 76 474) (om-make-point 67 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 0 0 nil 0) (5 0 3 0 nil 0) (7 0 3 1 nil 0) (2 0 4 0 nil 0) (4 1 5 0 nil 0) (6 0 5 1 nil 0) (7 0 6 0 nil 0) (4 0 7 0 nil 0) (1 0 7 1 nil 0))) 6.1 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 42 614) nil nil "l" "def->soundpath"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 405 470) (om-make-point 34 30) 90 "90" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "ratios-to-ms" (om-load-lisp-abspatch "ratios-to-ms" 6.1 ";;; Edit a valid LAMBDA EXPRESSION for \"ratios-to-ms\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (ratios tempo)$  (om* ratios (* (/ 60 tempo) 4)))") (quote ((om-load-inputfun (quote input-funbox) "" "RATIOS" nil) (om-load-inputfun (quote input-funbox) "" "TEMPO" nil))) (om-make-point 227 640) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ARR-REGIONS" (quote om-darwin::arr-regions) (quote ((om-load-inputfun (quote input-funbox) "ARR" "ARR" nil))) (om-make-point 200 357) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 465 734) (om-make-point 132 59) nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 510 628) (om-make-point 93 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 291 992) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "db" 1 (om-make-point 92 342) "" "db" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "engine" 0 (om-make-point 364 55) "" "engine" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 197 431) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 186 530) (om-make-point 108 59) nil nil nil 4))) (setf (numouts box) 4) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "PLACE-SOUNDS" (quote place-sounds) (quote ((om-load-inputfun (quote input-funbox) "" "SOUNDS" nil) (om-load-inputfun (quote input-funbox) "" "TIMES-1" nil) (om-load-inputfun (quote input-funbox) "" "DETUNES" nil))) (om-make-point 225 883) (om-make-point 114 67) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 106 789) (om-make-point 81 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "PHENOTYPE" (quote om-darwin::phenotype) (quote ((om-load-inputfun (quote input-funbox) "SELF" "SELF" nil))) (om-make-point 268 282) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "POPULATION" (quote om-darwin::population) (quote ((om-load-inputfun (quote input-funbox) "GA-ENGINE" "GA-ENGINE" nil))) (om-make-point 363 183) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CADAR" (quote cadar) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 291 221) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((7 0 0 1 nil 0) (10 0 2 0 nil 0) (1 0 2 1 nil 0) (13 0 3 0 nil 0) (5 0 4 0 nil 0) (10 3 5 0 nil 0) (11 0 6 0 nil 0) (3 0 9 0 nil 0) (9 0 10 0 nil 0) (12 0 11 0 nil 0) (2 0 11 1 nil 0) (4 1 11 2 nil 0) (0 0 12 0 nil 0) (4 0 12 1 nil 0) (15 0 13 0 nil 0) (8 0 14 0 nil 0) (14 0 15 0 nil 0))) 6.1 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 539 987) nil (list "/Users/holbrook/Data/projects/cbsolo-ws/out-files/easy-out-422.aiff") nil "defs->sound"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 39 190) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "easy-out-422.aiff" (quote sound) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "a track index for multichannel mixing (0 = no specific track)" "tracknum" 0) (om-load-inputfun (quote input-funbox) "a list of markers (s)" "markers" nil))) (om-make-point 880 838) (om-make-point 204 131) (let ((newobj (let ((thesound (load-sound (om-make-pathname :directory (quote (:relative "out-files")) :device :unspecific :host :unspecific :name "easy-out-422" :type "aiff") 0 100 0))) (when thesound (setf (markers thesound) (quote nil))) thesound))) (load-port-info newobj (quote nil)) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj "easy-out-422.aiff") (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (scale show-stems notechancolor? cmnpref obj-mode deltapict show-spectrum winpos winsize mode grillestep zoom player inport outport)) (list nil (quote t) nil (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) 0 (om-make-point 0 0) nil (om-make-point 400 20) (om-make-point 370 280) 0 nil 1 (quote :libaudiostream) nil nil)) t nil nil t))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 241 191) (om-make-point 34 30) 16 "16" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "DETUNED SAMPLE ENGINE" (quote om-darwin::ga-engine) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "" "model" nil) (om-load-inputfun (quote input-funbox) "" "fitness-function" nil))) (om-make-point 95 590) (om-make-point 321 205) (let ((om-darwin::ga (mki (quote om-darwin::ga-engine)))) (setf (om-darwin::model om-darwin::ga) nil) (setf (om-darwin::population om-darwin::ga) (list (list 0.0 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype nil :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) nil) (om-darwin::update om-darwin::spec) om-darwin::spec) 1354) (list 174.83989 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype nil :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) nil) (om-darwin::update om-darwin::spec) om-darwin::spec) 1) (list 374.77753 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype nil :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) nil) (om-darwin::update om-darwin::spec) om-darwin::spec) 7) (list 436.51602 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype nil :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) nil) (om-darwin::update om-darwin::spec) om-darwin::spec) 11) (list 585.4286 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype nil :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) nil) (om-darwin::update om-darwin::spec) om-darwin::spec) 11) (list 649.5744 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype nil :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) nil) (om-darwin::update om-darwin::spec) om-darwin::spec) 8) (list 745.488 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype nil :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) nil) (om-darwin::update om-darwin::spec) om-darwin::spec) 9) (list 803.3532 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype nil :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) nil) (om-darwin::update om-darwin::spec) om-darwin::spec) 5) (list 869.29377 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype nil :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) nil) (om-darwin::update om-darwin::spec) om-darwin::spec) 6) (list 935.69257 (let ((om-darwin::spec (if (find-class (quote om-darwin::om-specimen) nil) (make-instance (quote om-darwin::om-specimen) :raw-genotype nil :decoder nil :operons nil :pheno nil :from-file t)))) (setf (om-darwin::raw-genotype om-darwin::spec) nil) (om-darwin::update om-darwin::spec) om-darwin::spec) 7))) (setf (om-darwin::generation om-darwin::ga) 1377) (setf (om-darwin::result om-darwin::ga) (if (find-class (quote poly) nil) (let ((newobj (make-instance (quote poly) :voices (list (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (1 (((4 4) ((1 (1 1 2 2)) (1 (1 2 1 1 1)) (1 (2 1 1 1 1)) (1 (1.0 2 2 -1))))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (3550)) :ldur (quote (111)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (10650)) :ldur (quote (111)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6900)) :ldur (quote (222)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (3100)) :ldur (quote (222)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7300)) :ldur (quote (111)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (2100)) :ldur (quote (222)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7100)) :ldur (quote (111)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (3450)) :ldur (quote (111)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (8300)) :ldur (quote (111)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (2950)) :ldur (quote (222)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7150)) :ldur (quote (111)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (10850)) :ldur (quote (111)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5600)) :ldur (quote (111)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (9450)) :ldur (quote (111)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (4600)) :ldur (quote (222)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (9400)) :ldur (quote (222)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord)))) :tempo (quote ((1/4 90) nil)) :legato 100 :ties (quote (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote nil)) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote (nil))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))) om-darwin::ga) "x" nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 724 74) (om-make-point 370 280) 0 1000 nil 1 (quote :midi-player) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (list (quote ggff)) 24 2)) t nil nil t))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DEFINE-SPECIES" (quote define-species) (quote ((om-load-inputfun (quote input-funbox) "" "FUN" nil) (om-load-inputkeyword (quote input-keyword) "" "prop->pitch" (quote :prop->pitch) nil nil))) (om-make-point 116 451) (om-make-point 237 67) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "sample id and detune" (om-load-patch-abs1 "sample id and detune" (quote ((let ((box (om-load-boxcomment "comment" (om-make-point 100 60) (quote "sample identifier") "" (om-make-point 148 427) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 2" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 223 426) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-GENE" (quote om-gene) (quote ((om-load-inputfun (quote input-funbox) "minimum value" "MIN" 0) (om-load-inputfun (quote input-funbox) "maximum value" "MAX" 1))) (om-make-point 261 299) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "1-" (quote 1-) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 292 217) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 241 257) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "num-operons" 2 (om-make-point 730 88) "" "num-operons" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "EMBED-SPECIMEN" (quote embed-specimen) (quote ((om-load-inputfun (quote input-funbox) "" "SPEC" nil))) (om-make-point 714 540) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "PHENOTYPE" (quote om-darwin::phenotype) (quote ((om-load-inputfun (quote input-funbox) "SELF" "SELF" nil))) (om-make-point 757 660) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "COMBINE-RHYTHMS-AND-PITCHES" (quote om-darwin::combine-rhythms-and-pitches) (quote ((om-load-inputfun (quote input-funbox) "RHYTHM-ARR" "RHYTHM-ARR" nil) (om-load-inputfun (quote input-funbox) "PITCHES" "PITCHES" nil))) (om-make-point 534 758) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAKE-GRID-MELODY" (quote make-grid-melody) (quote ((om-load-inputfun (quote input-funbox) "" "NUM-NOTES" 8) (om-load-inputfun (quote input-funbox) "" "RANGE" (list 6000 7200)) (om-load-inputfun (quote input-funbox) "" "NOTE-VALUE" 1/16) (om-load-inputfun (quote input-funbox) "" "LEN-RANGE" (list 1 4)))) (om-make-point 749 417) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 5" (quote t) (quote nil) (om-make-point 870 244) (om-make-point 48 30) (list 0 0) "(0 0)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 6" (quote t) (quote nil) (om-make-point 940 240) (om-make-point 46 30) 1/24 "1/24" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 7" (quote t) (quote nil) (om-make-point 1005 276) (om-make-point 48 30) (list 1 2) "(1 2)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 105 263) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "1-" (quote 1-) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 156 223) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-GENE" (quote om-gene) (quote ((om-load-inputfun (quote input-funbox) "minimum value" "MIN" 0) (om-load-inputfun (quote input-funbox) "maximum value" "MAX" 1))) (om-make-point 125 305) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "max-folder-length" 1 (om-make-point 358 33) "" "max-folder-length" 16 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "N" 0))) (om-make-point 469 635) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 75 44) (quote "detune in midicents") "" (om-make-point 512 350) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 548 240) (om-make-point 34 30) 50 "50" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 10) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 460 353) (om-make-point 46 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 513 154) (om-make-point 27 30) 3 "3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 408 159) (om-make-point 32 30) -3 "-3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-GENE" (quote om-gene) (quote ((om-load-inputfun (quote input-funbox) "minimum value" "MIN" 0) (om-load-inputfun (quote input-funbox) "maximum value" "MAX" 1))) (om-make-point 430 246) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 632 859) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "num-folders" 0 (om-make-point 108 29) "" "num-folders" 255 (om-make-point 107 59)))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 327 537) (om-make-point 84 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((15 0 1 0 nil 0) (2 0 1 1 nil 0) (4 0 2 0 nil 0) (3 0 2 1 nil 0) (16 0 3 0 nil 0) (9 0 6 0 nil 0) (6 0 7 0 nil 0) (7 0 8 0 nil 0) (17 0 8 1 nil 0) (5 0 9 0 nil 0) (10 0 9 1 nil 0) (11 0 9 2 nil 0) (12 0 9 3 nil 0) (25 0 14 0 nil 0) (13 0 15 0 nil 0) (14 0 15 1 nil 0) (26 0 17 0 nil 0) (5 0 17 1 nil 0) (23 0 20 0 nil 0) (19 0 20 1 nil 0) (22 0 23 0 nil 0) (21 0 23 1 nil 0) (8 0 24 0 nil 0) (1 0 26 0 nil 0) (20 0 26 1 nil 0))) 6.1 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "num-folders" nil) (om-load-inputfun (quote input-funbox) "" "num-operons" nil) (om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 64 300) (om-make-point 163 67) (list nil) "l" "sample id and detune"))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 0 0 1 nil 3) (0 0 1 1 nil 0) (21 0 4 0 nil 0) (7 0 4 1 nil 0) (2 0 7 0 nil 0) (15 0 7 1 nil 0) (3 0 7 2 nil 0) (9 0 8 0 nil 0) (7 0 10 0 nil 0) (13 0 10 1 nil 0) (20 0 11 0 nil 0) (6 0 12 0 nil 3) (8 0 13 0 nil 0) (1 0 13 1 nil 0) (18 0 14 0 nil 0) (20 0 16 0 nil 0) (5 0 16 1 nil 0) (6 0 17 0 nil 3) (16 0 18 0 nil 0) (21 0 20 1 nil 0) (13 0 20 2 nil 0) (22 0 21 0 nil 0) (0 0 21 1 nil 0) (17 0 22 0 nil 0) (12 0 22 1 nil 0) (19 0 22 2 nil 0))) nil 6.1))
