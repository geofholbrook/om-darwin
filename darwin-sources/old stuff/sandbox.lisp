(in-package darwin);;; functionality test: here is how this ought to work(let (foo c m pop);;; create a hyper list (setf foo (make-h-list '(5 2) '(60 72)))  ;;; (tree foo) = '((62 68) (72 70) .... );;; same as (setf foo (make-h-list '(5 2) #'(lambda () (make-h-number nil '(60 72)))));;; create a criterion(setf c (make-crit #'diatonic)) ;;; evaluates diatonicness by h-atom ... oops not anymore;;; test evaluation(evaluate foo c) ;;; returns a count of negative tests (not a ratio!);;; test mutation(setf m (mutate foo))  ;;; (tree m) = '(2 1 . -5)  meaning, "moved second element of third list down by 5";;; (new value of foo should reflect m);;; make population(setf pop (make-population 'sp-Data c :dimensions '(5 2) :range '(60 72)));;; run population(print (run pop)));;; this is a note stepper! (a stepper of a stepper)(let*     ((step (mki 'stepper :goal 0.5 :sub-crit                (mki 'stepper :sub-crit (make-crit #'evenp))))     (pop (make-population 'sp-Data step :dimensions '(5 2) :range '(60 72))))  (print (run pop)))(let*     ((step (mki 'stepper :goal 0 :sub-crit                (mki 'stepper :sub-crit                      (mki 'basic-criterion                           :eval-fun #'melodic                          :comparison-fun #'(lambda (x goal) (within-M (abs x) goal))                          :goal '(2 4)))))     (pop (make-population 'sp-Data step :dimensions '(5 2) :range '(60 72))))  (print (run pop 100)))#|(setf sub1 (mki 'basic-criterion :eval-fun #'(lambda (n)                                              (memberp (mod (value n) 12)                                                       '(0 2 4 5 7 9 11)))))(setf sub2 (mki 'basic-criterion                 :eval-fun #'(lambda (c)                              (within-M (harmonic c :signed t) 4 7))                :subject-type :chord))(setf plural-sub (mki 'criteria                      :criteria (list sub1 sub2)))                (setf step1 (mki 'step-criterion :sub-crit sub1 :goal 1.0))(setf step2 (mki 'step-criterion :sub-crit sub2 :goal 0.0))(setf plural-step-a (mki 'criteria                         :criteria (list step1 step2)))(setf plural-step-b (mki 'step-criterion                         :sub-crit plural-sub))      (setf s (mki 'sp-chordseq))(evaluate s step2)(setf pop (make-population 'sp-chordseq step2 '(:len 10)))(run pop)|#